{"meta":{"title":"Kang's Blog","subtitle":"爱分享，乐学习","description":"","author":"Kang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-06-12T15:32:23.739Z","updated":"2020-06-12T15:32:23.739Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categories comments: false"},{"title":"tags","date":"2020-06-11T02:08:32.379Z","updated":"2020-06-11T02:08:32.379Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-06-13T15:01:46.000Z","updated":"2020-06-13T15:03:13.020Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"✏Java 笔记 ——IO 流📑","slug":"Blog-03","date":"2020-06-12T11:52:19.703Z","updated":"2020-06-13T03:00:21.018Z","comments":true,"path":"2020/06/12/Blog-03/","link":"","permalink":"http://yoursite.com/2020/06/12/Blog-03/","excerpt":"Java 学习 ——IO 流🌦🌦🌦","text":"Java 学习 ——IO 流🌦🌦🌦 &nbsp; &nbsp; Tips什么是字节流？字节流 —— 传输过程中，传输数据的最基本单位是字节的流。 什么是字符流？字符流 —— 传输过程中，传输数据的最基本单位是字符的流。 字符编码方式不同，有时候一个字符使用的字节数也不一样，比如 ASCLL 方式编码的字符，占一个字节；而 UTF-8 方式编码的字符，一个英文字符需要一个字节，一个中文需要三个字节。 字节数据是二进制形式的，要转成我们能识别的正常字符，需要选择正确的编码方式。我们生活中遇到的乱码问题就是字节数据没有选择正确的编码方式来显示成字符。 从本质上来讲，写数据（即输出）的时候，字节也好，字符也好，本质上都是没有标识符的，需要去指定编码方式。 但读数据的时候，如果我们需要去 “看数据”，那么字节流的数据需要指定字符编码方式，这样我们才能看到我们能识别的字符；而字符流，因为已经选择好了字符编码方式，通常不需要再改了（除非定义的字符编码方式与数据原有的编码方式不一致！） 在传输方面上，由于计算机的传输本质都是字节，而一个字符由多个字节组成，转成字节之前先要去查表转成字节，所以传输时有时候会使用缓冲区。 字节输入流 InputStream FileInputStream BufferedInputStream【BufferedInputStream 不是 InputStream 的直接实现子类，是 FilterInputStream 的子类】 区别与用途 InputStream 是字节输入流的抽象基类，InputStream 作为基类，给它的基类定义了几个通用的函数： read (byte [] b)：从流中读取 b 的长度个字节的数据存储到 b 中，返回结果是读取的字节个数（当再次读时，如果返回 -1 说明到了结尾，没有了数据） read (byte [] b, int off, int len)：从流中从 off 的位置开始读取 len 个字节的数据存储到 b 中，返回结果是实际读取到的字节个数（当再次读时，如果返回 - 1 说明到了结尾，没有了数据） close ()：关闭流，释放资源。 FileInputStream 主要用来操作文件输入流，它除了可以使用基类定义的函数外，它还实现了基类的 read () 函数（无参的）： read (): 从流中读取 1 个字节的数据，返回结果是一个 int，（如果编码是以一个字节一个字符的，可以尝试转成 char，用来查看数据）。 BufferedInputStream 带有缓冲的意思，普通的读是从硬盘里面读，而带有缓冲区之后，BufferedInputStream 已经提前将数据封装到内存中，内存中操作数据要快，所以它的效率要要非缓冲的要高。它除了可以使用基类定义的函数外，它还实现了基类的 read () 函数（无参的）： read (): 从流中读取 1 个字节的数据，返回结果是一个 int，（如果编码是以一个字节一个字符的，可以尝试转成 char，用来查看数据）。 使用 InputStream 是抽象基类，所以它不可以创建对象，但它可以用来 “接口化编程”，因为大部分子类的函数基类都有定义，所以利用基类来调用函数。 FileInputStream 是用来读文件数据的流，所以它需要一个文件对象用来实例化，这个文件可以是一个 File 对象，也可以是文件名路径字符串。 BufferedInputStream 是一种封装别的流以提高效率的流，所以它的初始化需要一个的 InputStream 流对象。 字节输出流 OutputStream FileOutputStream BufferedOutputStream【BufferedOutputStream 不是 OutputStream 的直接实现子类，是 FilterOutputStream 的子类】 区别与用途 OutputStream 是字节输出流的基类，OutputStream 作为基类，给它的基类定义了几个通用的函数： write (byte [] b): 将 b 的长度个字节数据写到输出流中。 write (byte [] b,int off,int len): 从 b 的 off 位置开始，获取 len 个字节数据，写到输出流中。 flush (): 刷新输出流，把数据马上写到输出流中。 close (): 关闭流，释放系统资源。 FileOutputStream 是用于写文件的输出流，它除了可以使用基类定义的函数外，还实现了 OutputStream 的抽象函数 write (int b): write (int b): 将 b 转成一个字节数据，写到输出流中。 BufferedOutputStream 像上面那个 BufferedInputStream 一样，都可以提高效率。它除了可以使用基类定义的函数外，它还实现了 OutputStream 的抽象函数 write (int b): write (int b): 将 b 转成一个字节数据，写到输出流中。 使用 OutputStream 是抽象基类，所以它不能实例化，但它可以用于接口化编程。 FileOutputStream 是用于写文件的输出流，所以它需要一个文件作为实例化参数，这个文件可以是 File 对象，也可以是文件路径字符串。【如果文件不存在，那么将自动创建】【FileOutputStream 实例化时可以给第二个参数，第二个参数是是否使用追加写入默认，为 true 时代表在原有文件内容后面追加写入数据，默认为 false】 BufferedOutputStream 需要一个输出流作为实例化参数。 字符输入流 Reader InputStreamReader FileReader BufferedReader 区别与用途 Reader 是字符输入流的抽象基类，它定义了以下几个函数： read ()：读取单个字符，返回结果是一个 int，需要转成 char; 到达流的末尾时，返回 - 1 read (char [] cbuf): 读取 cbuf 的长度个字符到 cbuf 这种，返回结果是读取的字符数，到达流的末尾时，返回 - 1 close ()：关闭流，释放占用的系统资源。 InputStreamReader 可以把 InputStream 中的字节数据流根据字符编码方式转成字符数据流。它除了可以使用基类定义的函数，它自己还实现了以下函数： read (char [] cbuf, int offset, int length) ：从 offset 位置开始，读取 length 个字符到 cbuf 中，返回结果是实际读取的字符数，到达流的末尾时，返回 - 1 FileReader 可以把 FileInputStream 中的字节数据转成根据字符编码方式转成字符数据流。 BufferedReader 可以把字符输入流进行封装，将数据进行缓冲，提高读取效率。它除了可以使用基类定义的函数，它自己还实现了以下函数： read (char [] cbuf, int offset, int length) ：从 offset 位置开始，读取 length 个字符到 cbuf 中，返回结果是实际读取的字符数，到达流的末尾时，返回 - 1 readLine ()：读取一个文本行，以行结束符作为末尾，返回结果是读取的字符串。如果已到达流末尾，则返回 null 使用 Reader 是一个抽象基类，不能实例化，但可以用于接口化编程。 InputStreamReader 需要一个字节输入流对象作为实例化参数。还可以指定第二个参数，第二个参数是字符编码方式，可以是编码方式的字符串形式，也可以是一个字符集对象。 FileReader 需要一个文件对象作为实例化参数，可以是 File 类对象，也可以是文件的路径字符串。 BufferReader 需要一个字符输入流对象作为实例化参数。 字符输出流 Writer OutputStreamWriter FileWriter BufferedWriter 区别与用途 Writer 是字符输出流的抽象基类， , 它定义了以下几个函数 write (char [] cbuf): 往输出流写入一个字符数组。 write (int c)：往输出流写入一个字符。 write (String str)：往输出流写入一串字符串。 write (String str, int off,int len) : 往输出流写入字符串的一部分。 close () ：关闭流，释放资源。【这个还是抽象的，写出来是说明有这个关闭功能】 flush ()：刷新输出流，把数据马上写到输出流中。【这个还是抽象的，写出来是说明有这个关闭功能】 OutputStreamWriter 可以使我们直接往流中写字符串数据，它里面会帮我们根据字符编码方式来把字符数据转成字节数据再写给输出流，它相当于一个中介 \\ 桥梁。 FileWriter 与 OutputStreamWriter 功能类似，我们可以直接往流中写字符串数据，FileWriter 内部会根据字符编码方式来把字符数据转成字节数据再写给输出流。 BufferedWriter 比 FileWriter 还高级一点，它利用了缓冲区来提高写的效率。它还多出了一个函数：newLine ()：写入一个换行符。 使用 Writer 是一个抽象基类，不能实例化，但可以用于接口化编程。 OutputStreamWriter 需要一个输入流对象作为实例化参数。 FileWriter 需要一个文件对象来实例化，可以是 File 类对象，也可以是文件的路径字符串。 BufferWriter 需要一个字符输出流对象作为实例化参数。 具体代码格式FileInputStream1234567891011121314151617181920212223242526272829import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class IOTest01 { public static void main(String[] args) { FileInputStream fis = null; try { fis = new FileInputStream(\"F:\\\\Java\\\\code\\\\Java-13\\\\src\\\\File01\"); byte[] b = new byte[4]; int i = 0; while((i = fis.read(b)) != -1) { // \"流\"--&gt;一步完成 System.out.print(new String(b,0,i)); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } }} FileOutputStream1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class IOTest02 { public static void main(String[] args) { FileOutputStream fos = null; try { fos = new FileOutputStream(\"F:\\\\Java\\\\code\\\\Java-13\\\\src\\\\File02\",true); // \"true\"---&gt;不清空文件添加内容 // 不加\"true\",默认为\"false\"，即清空文件添加内容 String s = \"不要在一切还来得及的时候，不着急；又在一切来不及的时候，选择放弃。\" + \"\\n\" + \"别在一切都还来得及的时候，不着急；又在一切都来不及的时候，选择放弃。\" + \"\\n\"; fos.write(s.getBytes()); fos.flush(); } catch (FileNotFoundException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } } }} FileReader1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class IOTest03 { public static void main(String[] args) { FileReader fr = null; try { fr = new FileReader(\"F:\\\\Java\\\\code\\\\Java-13\\\\src\\\\File03\"); int i = 0; char[] c = new char[4]; while((i = fr.read(c)) != -1) { System.out.print(c); } } catch (FileNotFoundException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } finally { if (fr != null) { try { fr.close(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } } }} FileWriter12345678910111213141516171819202122232425import java.io.FileWriter;import java.io.IOException;public class IOTest04 { public static void main(String[] args) { FileWriter fw = null; try { fw = new FileWriter(\"F:\\\\Java\\\\code\\\\Java-13\\\\src\\\\File04\",true); fw.write(\"那晚，我们都很开心。\"); fw.flush(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } finally { if (fw != null) { try { fw.close(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } } }} 总结📋【Java】学习之路可谓倒悬之危，课时较少，网课吸收较差，成功的把自己的未来寄托到了【B 站】, 顺利解锁 “我在 B 站上大学” 成就，该笔记内容绝大多数来自网络，以备后期复习。 都说 “不要重复造轮子”，那如果连 “造轮子” 的本事都没有，何谈 “重复” 呢？ &nbsp; 愿一切都好！！！👌","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"http://yoursite.com/tags/IO%E6%B5%81/"}]},{"title":"IDM 多线程下载器","slug":"Blog-02","date":"2020-06-09T16:13:40.852Z","updated":"2020-06-11T16:44:52.667Z","comments":true,"path":"2020/06/10/Blog-02/","link":"","permalink":"http://yoursite.com/2020/06/10/Blog-02/","excerpt":"今天填上一篇的坑","text":"今天填上一篇的坑 &nbsp; &nbsp; IDM 多线程下载器🌙🌙🌙 在上一篇中出现了这张图： &nbsp; 在【KinhDown 免费版】解析 Aria 链接后，自动弹出并请求下载，对！就是这么简单。这就是大名鼎鼎的【IDM】(Internet Download Manager) 安装下载，解压后安装，Windows 式” 下一步 “安装即可。 破解Patches📂中解压与电脑操作系统位数对应的压缩包 (解压密码：123)，右击 Patch 可执行程序，以管理员身份运行，继续【next】。再次点击 IDM，若界面出现 ⚡开始奔放⚡ 诚然，钱包鼓的话，可以去官网 http://www.internetdownloadmanager.com 支持一下！那它为什么这么快呢？说白了就是【多线程】。我们将下载一个文件这件事比作为接一桶水，按平常下载的情况就相当于开一个水龙头向桶里放水；当使用上 IDM，就相当于同时打开了多个水龙头往桶里放水，速度当然快起来了。【注】IDM 最大支持 32 线程。至此，电脑上的下载任务，IDM 就可以全局代理。","categories":[],"tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"IDM","slug":"IDM","permalink":"http://yoursite.com/tags/IDM/"}]},{"title":"First Blog","slug":"Blog-01","date":"2020-06-09T15:04:52.334Z","updated":"2020-06-13T08:38:15.659Z","comments":true,"path":"2020/06/09/Blog-01/","link":"","permalink":"http://yoursite.com/2020/06/09/Blog-01/","excerpt":"这是我的第一篇博客，很高兴能与大家分享！一来向大家安利一个好东西👀，二来锻炼我的 Markdown 编辑能力。","text":"这是我的第一篇博客，很高兴能与大家分享！一来向大家安利一个好东西👀，二来锻炼我的 Markdown 编辑能力。 &nbsp; &nbsp; 分享・毒盘不限速下载⚡⚡⚡ 准备工作 软件一款【KinhDown 免费版】 浏览器插件一个【网盘万能助手】 脑子一个【🧠】 使用教程 安装 【KinhDown 免费版】我更愿意叫它为 “KinhDown 绿色版”，因为该软件无需安装，双击即可运行。 【网盘万能助手】插件的安装，这里以 Microsoft Edge 为例，打开浏览器。 &nbsp; 确保打开 “开发人员模式”。 &nbsp; 将下载好的【网盘万能助手 v2.3.2.zip】直接拖入浏览器面板。 具体使用 点击【网盘万能助手】扩展，并【启用当前 UA】； 打开毒盘文件分享链接，点击【下载助手】—&gt;【显示 Aria 链接】。 &nbsp; 并【复制全部默认链接】，此时主角就要登场了，打开【KinhDown 免费版】，将复制的链接粘贴进去并解析。 &nbsp; [注意] 一定要在分享链接中复制 Aria 链接。🐷🐷🐷 &nbsp; 奔放下载中。。。。。。（可以跑满带宽） 实现原理 很深奥，很深奥。。。。。。（其实我也我不知道） 毒盘不限速下载的方法还有很多，譬如，【亿寻】、【Pandownload 复活版】等等，在各大电报群搜罗了一番，本着【互联网分享精神】介绍这一种目前还比较稳定的方法。","categories":[],"tags":[{"name":"百度","slug":"百度","permalink":"http://yoursite.com/tags/%E7%99%BE%E5%BA%A6/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"http://yoursite.com/tags/IO%E6%B5%81/"},{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"},{"name":"IDM","slug":"IDM","permalink":"http://yoursite.com/tags/IDM/"},{"name":"百度","slug":"百度","permalink":"http://yoursite.com/tags/%E7%99%BE%E5%BA%A6/"}]}